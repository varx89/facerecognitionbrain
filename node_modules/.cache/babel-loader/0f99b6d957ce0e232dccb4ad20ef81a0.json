{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Vector, getDistances, getStyleFromRgb, rangeColorToRgb } from \"tsparticles-engine\";\nexport function drawPolygonMask(context, rawData, stroke) {\n  var color = rangeColorToRgb(stroke.color);\n\n  if (!color) {\n    return;\n  }\n\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n\n  var _iterator = _createForOfIteratorHelper(rawData),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      context.lineTo(item.x, item.y);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  context.closePath();\n  context.strokeStyle = getStyleFromRgb(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n  context.translate(position.x, position.y);\n  var color = rangeColorToRgb(stroke.color);\n\n  if (!color) {\n    return;\n  }\n\n  context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n  var _a;\n\n  var res = [];\n\n  var _iterator2 = _createForOfIteratorHelper(paths),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var path = _step2.value;\n      var segments = path.element.pathSegList,\n          len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0,\n          p = {\n        x: 0,\n        y: 0\n      };\n\n      for (var i = 0; i < len; i++) {\n        var segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n        var svgPathSeg = window.SVGPathSeg;\n\n        switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n          case svgPathSeg.PATHSEG_MOVETO_ABS:\n          case svgPathSeg.PATHSEG_LINETO_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n          case svgPathSeg.PATHSEG_ARC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n            {\n              var absSeg = segment;\n              p.x = absSeg.x;\n              p.y = absSeg.y;\n              break;\n            }\n\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n            p.x = segment.x;\n            break;\n\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n            p.y = segment.y;\n            break;\n\n          case svgPathSeg.PATHSEG_LINETO_REL:\n          case svgPathSeg.PATHSEG_MOVETO_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n          case svgPathSeg.PATHSEG_ARC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n            {\n              var relSeg = segment;\n              p.x += relSeg.x;\n              p.y += relSeg.y;\n              break;\n            }\n\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n            p.x += segment.x;\n            break;\n\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n            p.y += segment.y;\n            break;\n\n          case svgPathSeg.PATHSEG_UNKNOWN:\n          case svgPathSeg.PATHSEG_CLOSEPATH:\n            continue;\n        }\n\n        res.push({\n          x: p.x * scale + offset.x,\n          y: p.y * scale + offset.y\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n  var _getDistances = getDistances(pos, s1),\n      dx = _getDistances.dx,\n      dy = _getDistances.dy,\n      _getDistances2 = getDistances(s2, s1),\n      dxx = _getDistances2.dx,\n      dyy = _getDistances2.dy,\n      t = (dx * dxx + dy * dyy) / (Math.pow(dxx, 2) + Math.pow(dyy, 2)),\n      res = {\n    x: s1.x + dxx * t,\n    y: s1.x + dyy * t,\n    isOnSegment: t >= 0 && t <= 1\n  };\n\n  if (t < 0) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > 1) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n\n  return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n  var _getDistances3 = getDistances(start, stop),\n      dx = _getDistances3.dx,\n      dy = _getDistances3.dy,\n      wallAngle = Math.atan2(dy, dx),\n      wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n      d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}","map":{"version":3,"names":["Vector","getDistances","getStyleFromRgb","rangeColorToRgb","drawPolygonMask","context","rawData","stroke","color","beginPath","moveTo","x","y","item","lineTo","closePath","strokeStyle","lineWidth","width","drawPolygonMaskPath","path","position","translate","opacity","parsePaths","paths","scale","offset","_a","res","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","calcClosestPtOnSegment","s1","s2","pos","dx","dy","dxx","dyy","t","isOnSegment","segmentBounce","start","stop","velocity","wallAngle","Math","atan2","wallNormal","create","sin","cos","d","multTo","subFrom"],"sources":["D:/Projects/facerecognitionbrain/node_modules/tsparticles-plugin-polygon-mask/esm/utils.js"],"sourcesContent":["import { Vector, getDistances, getStyleFromRgb, rangeColorToRgb } from \"tsparticles-engine\";\nexport function drawPolygonMask(context, rawData, stroke) {\n    const color = rangeColorToRgb(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.beginPath();\n    context.moveTo(rawData[0].x, rawData[0].y);\n    for (const item of rawData) {\n        context.lineTo(item.x, item.y);\n    }\n    context.closePath();\n    context.strokeStyle = getStyleFromRgb(color);\n    context.lineWidth = stroke.width;\n    context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n    context.translate(position.x, position.y);\n    const color = rangeColorToRgb(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n    context.lineWidth = stroke.width;\n    context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n    var _a;\n    const res = [];\n    for (const path of paths) {\n        const segments = path.element.pathSegList, len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0, p = {\n            x: 0,\n            y: 0,\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n            const svgPathSeg = window.SVGPathSeg;\n            switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\n                case svgPathSeg.PATHSEG_LINETO_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                case svgPathSeg.PATHSEG_ARC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\n                    const absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_REL:\n                case svgPathSeg.PATHSEG_MOVETO_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                case svgPathSeg.PATHSEG_ARC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\n                    const relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_UNKNOWN:\n                case svgPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n            }\n            res.push({\n                x: p.x * scale + offset.x,\n                y: p.y * scale + offset.y,\n            });\n        }\n    }\n    return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n    const { dx, dy } = getDistances(pos, s1), { dx: dxx, dy: dyy } = getDistances(s2, s1), t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2), res = {\n        x: s1.x + dxx * t,\n        y: s1.x + dyy * t,\n        isOnSegment: t >= 0 && t <= 1,\n    };\n    if (t < 0) {\n        res.x = s1.x;\n        res.y = s1.y;\n    }\n    else if (t > 1) {\n        res.x = s2.x;\n        res.y = s2.y;\n    }\n    return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n    const { dx, dy } = getDistances(start, stop), wallAngle = Math.atan2(dy, dx), wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)), d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n    wallNormal.multTo(d);\n    velocity.subFrom(wallNormal);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
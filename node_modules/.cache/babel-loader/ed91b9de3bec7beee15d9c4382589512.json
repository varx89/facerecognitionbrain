{"ast":null,"code":"import _slicedToArray from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { calculateBounds } from \"tsparticles-engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils\";\nexport var BounceOutMode = /*#__PURE__*/function () {\n  function BounceOutMode(container) {\n    _classCallCheck(this, BounceOutMode);\n\n    this.container = container;\n    this.modes = [\"bounce\", \"bounce-vertical\", \"bounce-horizontal\", \"bounceVertical\", \"bounceHorizontal\", \"split\"];\n  }\n\n  _createClass(BounceOutMode, [{\n    key: \"update\",\n    value: function update(particle, direction, delta, outMode) {\n      if (!this.modes.includes(outMode)) {\n        return;\n      }\n\n      var container = this.container;\n      var handled = false;\n\n      var _iterator = _createForOfIteratorHelper(container.plugins),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              plugin = _step$value[1];\n\n          if (plugin.particleBounce !== undefined) {\n            handled = plugin.particleBounce(particle, delta, direction);\n          }\n\n          if (handled) {\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (handled) {\n        return;\n      }\n\n      var pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.getRadius(),\n          bounds = calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n      bounceHorizontal({\n        particle: particle,\n        outMode: outMode,\n        direction: direction,\n        bounds: bounds,\n        canvasSize: canvasSize,\n        offset: offset,\n        size: size\n      });\n      bounceVertical({\n        particle: particle,\n        outMode: outMode,\n        direction: direction,\n        bounds: bounds,\n        canvasSize: canvasSize,\n        offset: offset,\n        size: size\n      });\n    }\n  }]);\n\n  return BounceOutMode;\n}();","map":{"version":3,"names":["calculateBounds","bounceHorizontal","bounceVertical","BounceOutMode","container","modes","particle","direction","delta","outMode","includes","handled","plugins","plugin","particleBounce","undefined","pos","getPosition","offset","size","getRadius","bounds","canvasSize","canvas"],"sources":["D:/Projects/facerecognitionbrain/node_modules/tsparticles-updater-out-modes/esm/BounceOutMode.js"],"sourcesContent":["import { calculateBounds } from \"tsparticles-engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"bounce-vertical\",\n            \"bounce-horizontal\",\n            \"bounceVertical\",\n            \"bounceHorizontal\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n"],"mappings":";;;;AAAA,SAASA,eAAT,QAAgC,oBAAhC;AACA,SAASC,gBAAT,EAA2BC,cAA3B,QAAiD,SAAjD;AACA,WAAaC,aAAb;EACI,uBAAYC,SAAZ,EAAuB;IAAA;;IACnB,KAAKA,SAAL,GAAiBA,SAAjB;IACA,KAAKC,KAAL,GAAa,CACT,QADS,EAET,iBAFS,EAGT,mBAHS,EAIT,gBAJS,EAKT,kBALS,EAMT,OANS,CAAb;EAQH;;EAXL;IAAA;IAAA,OAYI,gBAAOC,QAAP,EAAiBC,SAAjB,EAA4BC,KAA5B,EAAmCC,OAAnC,EAA4C;MACxC,IAAI,CAAC,KAAKJ,KAAL,CAAWK,QAAX,CAAoBD,OAApB,CAAL,EAAmC;QAC/B;MACH;;MACD,IAAML,SAAS,GAAG,KAAKA,SAAvB;MACA,IAAIO,OAAO,GAAG,KAAd;;MALwC,2CAMfP,SAAS,CAACQ,OANK;MAAA;;MAAA;QAMxC,oDAA4C;UAAA;UAAA,IAA9BC,MAA8B;;UACxC,IAAIA,MAAM,CAACC,cAAP,KAA0BC,SAA9B,EAAyC;YACrCJ,OAAO,GAAGE,MAAM,CAACC,cAAP,CAAsBR,QAAtB,EAAgCE,KAAhC,EAAuCD,SAAvC,CAAV;UACH;;UACD,IAAII,OAAJ,EAAa;YACT;UACH;QACJ;MAbuC;QAAA;MAAA;QAAA;MAAA;;MAcxC,IAAIA,OAAJ,EAAa;QACT;MACH;;MACD,IAAMK,GAAG,GAAGV,QAAQ,CAACW,WAAT,EAAZ;MAAA,IAAoCC,MAAM,GAAGZ,QAAQ,CAACY,MAAtD;MAAA,IAA8DC,IAAI,GAAGb,QAAQ,CAACc,SAAT,EAArE;MAAA,IAA2FC,MAAM,GAAGrB,eAAe,CAACgB,GAAD,EAAMG,IAAN,CAAnH;MAAA,IAAgIG,UAAU,GAAGlB,SAAS,CAACmB,MAAV,CAAiBJ,IAA9J;MACAlB,gBAAgB,CAAC;QAAEK,QAAQ,EAARA,QAAF;QAAYG,OAAO,EAAPA,OAAZ;QAAqBF,SAAS,EAATA,SAArB;QAAgCc,MAAM,EAANA,MAAhC;QAAwCC,UAAU,EAAVA,UAAxC;QAAoDJ,MAAM,EAANA,MAApD;QAA4DC,IAAI,EAAJA;MAA5D,CAAD,CAAhB;MACAjB,cAAc,CAAC;QAAEI,QAAQ,EAARA,QAAF;QAAYG,OAAO,EAAPA,OAAZ;QAAqBF,SAAS,EAATA,SAArB;QAAgCc,MAAM,EAANA,MAAhC;QAAwCC,UAAU,EAAVA,UAAxC;QAAoDJ,MAAM,EAANA,MAApD;QAA4DC,IAAI,EAAJA;MAA5D,CAAD,CAAd;IACH;EAhCL;;EAAA;AAAA"},"metadata":{},"sourceType":"module"}
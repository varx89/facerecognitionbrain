{"ast":null,"code":"import _classCallCheck from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"D:/Projects/facerecognitionbrain/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange } from \"tsparticles-engine\";\nexport var OutOutMode = /*#__PURE__*/function () {\n  function OutOutMode(container) {\n    _classCallCheck(this, OutOutMode);\n\n    this.container = container;\n    this.modes = [\"out\"];\n  }\n\n  _createClass(OutOutMode, [{\n    key: \"update\",\n    value: function update(particle, direction, delta, outMode) {\n      if (!this.modes.includes(outMode)) {\n        return;\n      }\n\n      var container = this.container;\n\n      switch (particle.outType) {\n        case \"inside\":\n          {\n            var _particle$velocity = particle.velocity,\n                vx = _particle$velocity.x,\n                vy = _particle$velocity.y;\n            var circVec = Vector.origin;\n            circVec.length = particle.moveCenter.radius;\n            circVec.angle = particle.velocity.angle + Math.PI;\n            circVec.addTo(Vector.create(particle.moveCenter));\n\n            var _getDistances = getDistances(particle.position, circVec),\n                dx = _getDistances.dx,\n                dy = _getDistances.dy;\n\n            if (vx <= 0 && dx >= 0 || vy <= 0 && dy >= 0 || vx >= 0 && dx <= 0 || vy >= 0 && dy <= 0) {\n              return;\n            }\n\n            particle.position.x = Math.floor(randomInRange({\n              min: 0,\n              max: container.canvas.size.width\n            }));\n            particle.position.y = Math.floor(randomInRange({\n              min: 0,\n              max: container.canvas.size.height\n            }));\n\n            var _getDistances2 = getDistances(particle.position, particle.moveCenter),\n                newDx = _getDistances2.dx,\n                newDy = _getDistances2.dy;\n\n            particle.direction = Math.atan2(-newDy, -newDx);\n            particle.velocity.angle = particle.direction;\n            break;\n          }\n\n        default:\n          {\n            if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n              return;\n            }\n\n            switch (particle.outType) {\n              case \"outside\":\n                {\n                  particle.position.x = Math.floor(randomInRange({\n                    min: -particle.moveCenter.radius,\n                    max: particle.moveCenter.radius\n                  })) + particle.moveCenter.x;\n                  particle.position.y = Math.floor(randomInRange({\n                    min: -particle.moveCenter.radius,\n                    max: particle.moveCenter.radius\n                  })) + particle.moveCenter.y;\n\n                  var _getDistances3 = getDistances(particle.position, particle.moveCenter),\n                      _dx = _getDistances3.dx,\n                      _dy = _getDistances3.dy;\n\n                  if (particle.moveCenter.radius) {\n                    particle.direction = Math.atan2(_dy, _dx);\n                    particle.velocity.angle = particle.direction;\n                  }\n\n                  break;\n                }\n\n              case \"normal\":\n                {\n                  var wrap = particle.options.move.warp,\n                      canvasSize = container.canvas.size,\n                      newPos = {\n                    bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                    left: -particle.getRadius() - particle.offset.x,\n                    right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                    top: -particle.getRadius() - particle.offset.y\n                  },\n                      sizeValue = particle.getRadius(),\n                      nextBounds = calculateBounds(particle.position, sizeValue);\n\n                  if (direction === \"right\" && nextBounds.left > canvasSize.width + particle.offset.x) {\n                    particle.position.x = newPos.left;\n                    particle.initialPosition.x = particle.position.x;\n\n                    if (!wrap) {\n                      particle.position.y = getRandom() * canvasSize.height;\n                      particle.initialPosition.y = particle.position.y;\n                    }\n                  } else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                    particle.position.x = newPos.right;\n                    particle.initialPosition.x = particle.position.x;\n\n                    if (!wrap) {\n                      particle.position.y = getRandom() * canvasSize.height;\n                      particle.initialPosition.y = particle.position.y;\n                    }\n                  }\n\n                  if (direction === \"bottom\" && nextBounds.top > canvasSize.height + particle.offset.y) {\n                    if (!wrap) {\n                      particle.position.x = getRandom() * canvasSize.width;\n                      particle.initialPosition.x = particle.position.x;\n                    }\n\n                    particle.position.y = newPos.top;\n                    particle.initialPosition.y = particle.position.y;\n                  } else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                    if (!wrap) {\n                      particle.position.x = getRandom() * canvasSize.width;\n                      particle.initialPosition.x = particle.position.x;\n                    }\n\n                    particle.position.y = newPos.bottom;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n\n                  break;\n                }\n            }\n\n            break;\n          }\n      }\n    }\n  }]);\n\n  return OutOutMode;\n}();","map":{"version":3,"names":["Vector","calculateBounds","getDistances","getRandom","isPointInside","randomInRange","OutOutMode","container","modes","particle","direction","delta","outMode","includes","outType","velocity","vx","x","vy","y","circVec","origin","length","moveCenter","radius","angle","Math","PI","addTo","create","position","dx","dy","floor","min","max","canvas","size","width","height","newDx","newDy","atan2","getRadius","wrap","options","move","warp","canvasSize","newPos","bottom","offset","left","right","top","sizeValue","nextBounds","initialPosition"],"sources":["D:/Projects/facerecognitionbrain/node_modules/tsparticles-updater-out-modes/esm/OutOutMode.js"],"sourcesContent":["import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"tsparticles-engine\";\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= 0 && dx >= 0) || (vy <= 0 && dy >= 0) || (vx >= 0 && dx <= 0) || (vy >= 0 && dy <= 0)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}